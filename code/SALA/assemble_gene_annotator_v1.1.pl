#!/usr/bin/env perl

#====================================================================================================================================================#
#<use>
$|++; #---turn on the auto flush for the progress bar
no warnings 'utf8';
use warnings;
use strict;
use File::Path;
use File::Copy;
use File::Basename;
use File::Spec::Functions qw(rel2abs abs2rel);
use Time::HiRes qw( time );
use threads ('stack_size' => 64*4096);
use threads::shared;
use Getopt::Long 'HelpMessage';
use List::Util qw (sum shuffle min max);
use Cwd 'abs_path';
use AutoLoader qw/AUTOLOAD/;
#<\use>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<doc>
=head1 SYNOPSIS

 Description:
   This tool annnotate the models of the end5 guided assembler as genes

 Usage:
   assemble_gene_annotator_v1.1.pl [options] --qry_bed_bgz --ref_bed_bgz --out_dir
   
   --model_bed_bgz             <required> [path]    generated by end5_guided_assembler, contain info for all reference transcripts
   --model_info_gz             <required> [path]    generated by end5_guided_assembler, contain info for all reference transcripts
   --ref_model_gene_link       <required> [path]    transcript ID to gene ID link of reference transcriptome, columns 1-5: transcript_id, gene_id, transcript_type, gene_type, gene_name
   --out_dir                   <required> [path]    output directory
   --revert_ref_model_bed_bgz      (optional) [path]    if input, will revert the model without qry support back to the bounds in the revert_ref_model_bed_bgz bed input
   --out_prefix                (optional) [string]  output files prefix, if not defined, qry_bed_bgz filename will be used
   --novel_gene_prefix         (optional) [string]  prefix of the novel gene models [default=ONTC]
   --max_thread                (optional) [integer] number of threads to be used [default=5]
   --bedtools_bin              (optional) [path]    path to the binary of bedtools, if not provided, "bedtools" will be called
   --tabix_bin                 (optional) [path]    path to the binary of tabix, if not provided, "tabix" will be called
   --bgzip_bin                 (optional) [path]    path to the binary of bgzip, if not provided, "bgzip" will be called

 Dependencies:
   perl
   bedtools
   tabix
   bgzip
   

=head1 VERSION

1.1   -debut
=cut
#<\doc>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<lastCmdCalled>
#
#	notCalledBefore
#
#	notCalledBefore
#
#<\lastCmdCalled>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<global>
my $scriptDirPath = dirname(rel2abs($0));
my $scriptAbsPath = abs_path($0);
my ($curntTimeStamp) = &timeStamp();#->1693
my $ARGVStr = join "\n", (&currentTime(), $scriptAbsPath, @ARGV);#->430
my $globalReadmeHsh_ref = {};
our $tmplog_fh;
#<\global>
#====================================================================================================================================================#

#====================================================================================================================================================#
{	#Main sections lexical scope starts
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 0_startingTasks
#
#<section ID="startingTasks" num="0">
my ($model_bed_bgz, $model_info_gz, $ref_model_gene_link, $novel_gene_prefix, $exon_overlap_dist, $min_ref_exon_overlap_pct, $locus_merge_dist, $exclude_t_type, $revert_ref_model_bed_bgz, $disable_ref_chain_bound_gene_anno, $chrom_size_path, $bedtools_bin, $tabix_bin, $bgzip_bin, $max_thread, $out_prefix, $out_dir) = &readParameters();#->1469
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 1_defineHardCodedParam
#
#<section ID="defineHardCodedParam" num="1">
my $paramTag = "$out_prefix";
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 2_defineout_dirPath
#
#<section ID="defineout_dirPath" num="2">
my @mkDirAry;
my $result_dir = "$out_dir/$paramTag"; push @mkDirAry, $result_dir;
my $result_tmp_dir = "$result_dir/tmp/"; push @mkDirAry, $result_tmp_dir;
my $result_bed_dir = "$result_dir/bed/"; push @mkDirAry, $result_bed_dir;
my $result_log_dir = "$result_dir/log/"; push @mkDirAry, $result_log_dir;
my $result_script_dir = "$result_dir/script/"; push @mkDirAry, $result_script_dir;
foreach my $dir (@mkDirAry) {system ("mkdir -pm 777 $dir");}

open $tmplog_fh, ">", "$result_dir/00_screen_log.$curntTimeStamp.log.txt";
&logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);#->889
&printStartOrFinishMessage("startMessage");#->1244
&reportAndLogStatus("Parameters:", 10, "\n");#->1613
&reportAndLogStatus("model_bed_bgz = $model_bed_bgz", 10, "\n");#->1613
&reportAndLogStatus("model_info_gz = $model_info_gz", 10, "\n");#->1613
&reportAndLogStatus("ref_model_gene_link = $ref_model_gene_link", 10, "\n");#->1613
&reportAndLogStatus("novel_gene_prefix = $novel_gene_prefix", 10, "\n");#->1613
&reportAndLogStatus("exon_overlap_dist = $exon_overlap_dist", 10, "\n");#->1613
&reportAndLogStatus("min_ref_exon_overlap_pct = $min_ref_exon_overlap_pct", 10, "\n");#->1613
&reportAndLogStatus("locus_merge_dist = $locus_merge_dist", 10, "\n");#->1613
&reportAndLogStatus("exclude_t_type = $exclude_t_type", 10, "\n");#->1613
&reportAndLogStatus("disable_ref_chain_bound_gene_anno = $disable_ref_chain_bound_gene_anno", 10, "\n");#->1613

&reportAndLogStatus("Start processing......", 10, "\n");#->1613
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 3_process
#
#<section ID="process" num="3">
my $g_assign_hsh_ref = {
	'00' => '00_inherited',
	'01' => '01_ref_exon_ovrlp',
	'02' => '02_ref_chain_bound_from_ref',
	'03' => '03_ref_chain_bound_from_non_ref',
	'04' => '04_novel_chain',
	'05' => '05_orphan_model',
};

my ($chrom_info_hsh_ref) = &defineChromInfo($chrom_size_path, $result_tmp_dir);#->549
my ($locus_info_hsh_ref, $chain_info_hsh_ref, $model_info_hsh_ref, $gene_info_hsh_ref) = &processPerChromosome($chrom_info_hsh_ref, $model_bed_bgz, $model_info_gz, $revert_ref_model_bed_bgz, $ref_model_gene_link, $novel_gene_prefix, $exon_overlap_dist, $locus_merge_dist, $bedtools_bin, $tabix_bin, $bgzip_bin, $max_thread, $paramTag, $exclude_t_type, $g_assign_hsh_ref, $disable_ref_chain_bound_gene_anno, $min_ref_exon_overlap_pct);#->1332
&reportAndLogStatus("Printing model info and bed......", 10, "\n");#->1613
&printModelInfoAndBed($result_log_dir, $paramTag, $model_info_hsh_ref, $gene_info_hsh_ref, $result_bed_dir, $bgzip_bin, $tabix_bin);#->1059
&reportAndLogStatus("Printing gene info and bed......", 10, "\n");#->1613
&printGeneInfoAndBed($result_log_dir, $paramTag, $gene_info_hsh_ref, $result_bed_dir, $bgzip_bin, $tabix_bin);#->989
&reportAndLogStatus("Printing chain info and bed......", 10, "\n");#->1613
&printChainInfoAndBed($result_log_dir, $paramTag, $chain_info_hsh_ref, $gene_info_hsh_ref, $result_bed_dir, $bgzip_bin, $tabix_bin);#->914
#system "rm -rf $result_tmp_dir";
system "chmod -R 755 $result_dir";

#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 4_finishingTasks
#
#<section ID="finishingTasks" num="4">
&printOutputFileListAndReadme($ARGVStr, $paramTag, $out_dir);#->1129
&printStartOrFinishMessage("finishMessage");#->1244
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
}	#Main sections lexical scope ends
#====================================================================================================================================================#

#====================================================================================================================================================#
#List of subroutines by category
#
#	general [n=5]:
#		currentTime, logCalledCMDAndScript, printStartOrFinishMessage
#		readParameters, timeStamp
#
#	log [n=1]:
#		reportAndLogStatus
#
#	output [n=1]:
#		printOutputFileListAndReadme
#
#	time [n=1]:
#		timeStamp
#
#	unassigned [n=24]:
#		aggregateModel, assignNewGeneIDInChain, assignRefGeneIDByExonOverlap
#		assignRefGeneIDByInheritance, assignRefGeneIDInRefChainUsingBoundStringFromNonRefModels, assignRefGeneIDInRefChainUsingBoundStringFromRefModels
#		cleanUpModelHsh, deepAmendHash, defineChainAndAssignGene
#		defineChromInfo, defineExonCluster, defineLocus
#		defineOrphanExonCluster, defineRefGeneExon, getModelBoundStr
#		getModelInChrom, intersectModelWithRefExon, printChainInfoAndBed
#		printGeneInfoAndBed, printModelInfoAndBed, processOrphanModel
#		processPerChromosome, readRefGeneID, summarizeGeneInfo
#
#====================================================================================================================================================#

sub aggregateModel {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1613
#	appearInSub: defineChainAndAssignGene|476, processOrphanModel|1278
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $all_hit_hsh_ref, $cluster_key, $exclude_hit_hsh_ref, $exon_cluster_hsh_ref, $model_info_hsh_ref, $seed_model_ID
#	output: $all_hit_hsh_ref
#	toCall: my ($all_hit_hsh_ref) = &aggregateModel($all_hit_hsh_ref, $seed_model_ID, $model_info_hsh_ref, $exon_cluster_hsh_ref, $exclude_hit_hsh_ref, $cluster_key);
#	calledInLine: 234, 510, 1314
#....................................................................................................................................................#
	my ($all_hit_hsh_ref, $seed_model_ID, $model_info_hsh_ref, $exon_cluster_hsh_ref, $exclude_hit_hsh_ref, $cluster_key) = @_;
	
	my $round_hit_hsh_ref = {};

	$all_hit_hsh_ref->{$seed_model_ID}++;
	foreach my $cluster_ID (@{$model_info_hsh_ref->{$seed_model_ID}{$cluster_key}}) {
		foreach my $hit_model_ID (@{$exon_cluster_hsh_ref->{$cluster_ID}}) {
			next if $hit_model_ID eq $seed_model_ID;
			next if exists $exclude_hit_hsh_ref->{$hit_model_ID};
			next if exists $all_hit_hsh_ref->{$hit_model_ID};
			$round_hit_hsh_ref->{$hit_model_ID}++;
			$all_hit_hsh_ref->{$hit_model_ID}++;
			#$exclude_hit_hsh_ref->{$hit_model_ID}++;
		}
	}
	
	my $num_hit = keys %{$round_hit_hsh_ref};
	#&reportAndLogStatus("num_hit=$num_hit", 10, "\n") if $num_hit == 0;#->1613
	if ($num_hit > 0) {
		foreach my $hit_model_ID (keys %{$round_hit_hsh_ref}) {
			($all_hit_hsh_ref) = &aggregateModel($all_hit_hsh_ref, $hit_model_ID, $model_info_hsh_ref, $exon_cluster_hsh_ref, $exclude_hit_hsh_ref, $cluster_key);#->203
		}
	}

	return ($all_hit_hsh_ref);
}
sub assignNewGeneIDInChain {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: defineChainAndAssignGene|476, processOrphanModel|1278
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $all_hit_hsh_ref, $chain_ID, $chain_info_hsh_ref, $chrom_num, $g_assign, $gene_info_hsh_ref, $gene_num, $model_info_hsh_ref, $novel_gene_prefix
#	output: $gene_num
#	toCall: my ($gene_num) = &assignNewGeneIDInChain($gene_num, $novel_gene_prefix, $chrom_num, $gene_info_hsh_ref, $chain_info_hsh_ref, $model_info_hsh_ref, $all_hit_hsh_ref, $g_assign, $chain_ID);
#	calledInLine: 538, 1321
#....................................................................................................................................................#
	my ($gene_num, $novel_gene_prefix, $chrom_num, $gene_info_hsh_ref, $chain_info_hsh_ref, $model_info_hsh_ref, $all_hit_hsh_ref, $g_assign, $chain_ID) = @_;
	
	$gene_num++;
	$gene_num = sprintf "%.9d", $gene_num;
	my $gene_name = $novel_gene_prefix.$chrom_num.$gene_num;
	my $gene_ID = $gene_name.".1";
	$gene_info_hsh_ref->{$gene_ID}{'g_type'} = 'novel';
	$gene_info_hsh_ref->{$gene_ID}{'gene_name'} = $gene_name;
	push @{$chain_info_hsh_ref->{$chain_ID}{'gene_ID'}}, $gene_ID;
	foreach my $hit_model_ID (keys %{$all_hit_hsh_ref}) {
		$model_info_hsh_ref->{$hit_model_ID}{'gene_ID'} = $gene_ID;
		$model_info_hsh_ref->{$hit_model_ID}{'g_assign'} = $g_assign;
	}

	return ($gene_num);
}
sub assignRefGeneIDByExonOverlap {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: intersectModelWithRefExon|840
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $g_assign_hsh_ref, $gene_ID, $model_ID, $model_info_hsh_ref
#	output: 
#	toCall: &assignRefGeneIDByExonOverlap($model_ID, $gene_ID, $model_info_hsh_ref, $g_assign_hsh_ref);
#	calledInLine: 882
#....................................................................................................................................................#
	my ($model_ID, $gene_ID, $model_info_hsh_ref, $g_assign_hsh_ref) = @_;

	$model_info_hsh_ref->{$model_ID}{'g_assign'} = $g_assign_hsh_ref->{'01'};
	$model_info_hsh_ref->{$model_ID}{'gene_ID'} = $gene_ID;

	return ();
}
sub assignRefGeneIDByInheritance {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: readRefGeneID|1569
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $g_assign_hsh_ref, $g_type, $gene_ID, $gene_info_hsh_ref, $gene_name, $model_ID, $model_info_hsh_ref
#	output: 
#	toCall: &assignRefGeneIDByInheritance($model_ID, $gene_ID, $gene_info_hsh_ref, $g_type, $gene_name, $model_info_hsh_ref, $g_assign_hsh_ref);
#	calledInLine: 1596
#....................................................................................................................................................#
	my ($model_ID, $gene_ID, $gene_info_hsh_ref, $g_type, $gene_name, $model_info_hsh_ref, $g_assign_hsh_ref) = @_;

	$model_info_hsh_ref->{$model_ID}{'g_assign'} = $g_assign_hsh_ref->{'00'};
	$model_info_hsh_ref->{$model_ID}{'gene_ID'} = $gene_ID;
	$gene_info_hsh_ref->{$gene_ID}{'g_type'} = $g_type;
	$gene_info_hsh_ref->{$gene_ID}{'gene_name'} = $gene_name;

	return ();
}
sub assignRefGeneIDInRefChainUsingBoundStringFromNonRefModels {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: defineChainAndAssignGene|476
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $all_hit_hsh_ref, $g_assign_hsh_ref, $gene_info_hsh_ref, $model_info_hsh_ref
#	output: 
#	toCall: &assignRefGeneIDInRefChainUsingBoundStringFromNonRefModels($all_hit_hsh_ref, $model_info_hsh_ref, $gene_info_hsh_ref, $g_assign_hsh_ref);
#	calledInLine: 534
#....................................................................................................................................................#
	my ($all_hit_hsh_ref, $model_info_hsh_ref, $gene_info_hsh_ref, $g_assign_hsh_ref) = @_;

	#---[2023/08/04 15:09] define bound string geneID hsh
	my $bound_str_hsh_ref = {};
	foreach my $hit_model_ID (keys %{$all_hit_hsh_ref}) {
		if (exists $model_info_hsh_ref->{$hit_model_ID}{'gene_ID'} and $model_info_hsh_ref->{$hit_model_ID}{'ref'} eq 'N') { #---[2023/09/15 21:12] non-ref transcripts only
			my $gene_ID = $model_info_hsh_ref->{$hit_model_ID}{'gene_ID'};
			foreach my $bound_str (@{$model_info_hsh_ref->{$hit_model_ID}{'BS'}}) {
				$bound_str_hsh_ref->{$bound_str}{$gene_ID}++;
			}
		}
	}
	
	#---[2023/08/04 15:09] transfer geneID if bound string hit
	foreach my $hit_model_ID (keys %{$all_hit_hsh_ref}) {
		if (not exists $model_info_hsh_ref->{$hit_model_ID}{'gene_ID'}) {
			my $gene_ID_count_hsh_ref = {};
			foreach my $bound_str (@{$model_info_hsh_ref->{$hit_model_ID}{'BS'}}) {
				if (exists $bound_str_hsh_ref->{$bound_str}) {
					foreach my $gene_ID (keys %{$bound_str_hsh_ref->{$bound_str}}) {
						$gene_ID_count_hsh_ref->{$gene_ID}++;
					}
				}
			}
			
			if (keys %{$gene_ID_count_hsh_ref} > 0) {
				foreach my $gene_ID (sort {$gene_ID_count_hsh_ref->{$b} <=> $gene_ID_count_hsh_ref->{$a}} keys %{$gene_ID_count_hsh_ref}) {
					$model_info_hsh_ref->{$hit_model_ID}{'gene_ID'} = $gene_ID;
					$model_info_hsh_ref->{$hit_model_ID}{'g_assign'} = $g_assign_hsh_ref->{'03'};
					last;
				}
			}
		}
	}
	
	return ();
}
sub assignRefGeneIDInRefChainUsingBoundStringFromRefModels {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: defineChainAndAssignGene|476
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $all_hit_hsh_ref, $g_assign_hsh_ref, $gene_info_hsh_ref, $model_info_hsh_ref
#	output: 
#	toCall: &assignRefGeneIDInRefChainUsingBoundStringFromRefModels($all_hit_hsh_ref, $model_info_hsh_ref, $gene_info_hsh_ref, $g_assign_hsh_ref);
#	calledInLine: 532
#....................................................................................................................................................#
	my ($all_hit_hsh_ref, $model_info_hsh_ref, $gene_info_hsh_ref, $g_assign_hsh_ref) = @_;

	#---[2023/08/04 15:09] define bound string geneID hsh
	my $bound_str_hsh_ref = {};
	foreach my $hit_model_ID (keys %{$all_hit_hsh_ref}) {
		if ($model_info_hsh_ref->{$hit_model_ID}{'ref'} eq 'Y') { #---[2023/09/15 21:12] ref transcripts only
			my $gene_ID = $model_info_hsh_ref->{$hit_model_ID}{'gene_ID'};
			foreach my $bound_str (@{$model_info_hsh_ref->{$hit_model_ID}{'BS'}}) {
				$bound_str_hsh_ref->{$bound_str}{$gene_ID}++;
			}
		}
	}
	
	#---[2023/08/04 15:09] transfer geneID if bound string hit
	foreach my $hit_model_ID (keys %{$all_hit_hsh_ref}) {
		if (not exists $model_info_hsh_ref->{$hit_model_ID}{'gene_ID'}) {
			my $gene_ID_count_hsh_ref = {};
			foreach my $bound_str (@{$model_info_hsh_ref->{$hit_model_ID}{'BS'}}) {
				if (exists $bound_str_hsh_ref->{$bound_str}) {
					foreach my $gene_ID (keys %{$bound_str_hsh_ref->{$bound_str}}) {
						$gene_ID_count_hsh_ref->{$gene_ID}++;
					}
				}
			}
			
			if (keys %{$gene_ID_count_hsh_ref} > 0) {
				foreach my $gene_ID (sort {$gene_ID_count_hsh_ref->{$b} <=> $gene_ID_count_hsh_ref->{$a}} keys %{$gene_ID_count_hsh_ref}) {
					$model_info_hsh_ref->{$hit_model_ID}{'gene_ID'} = $gene_ID;
					$model_info_hsh_ref->{$hit_model_ID}{'g_assign'} = $g_assign_hsh_ref->{'02'};
					last;
				}
			}
		}
	}
	
	return ();
}
sub cleanUpModelHsh {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: processPerChromosome|1332
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_process|135
#	input: $key_delete_ary_ref, $model_info_hsh_ref
#	output: 
#	toCall: &cleanUpModelHsh($model_info_hsh_ref, $key_delete_ary_ref);
#	calledInLine: 1415
#....................................................................................................................................................#
	my ($model_info_hsh_ref, $key_delete_ary_ref) = @_;
	
	foreach my $model_ID (keys %{$model_info_hsh_ref}) {
		die "$model_ID has no geneID\n" if not exists $model_info_hsh_ref->{$model_ID}{'gene_ID'};
		foreach my $key (@{$key_delete_ary_ref}) {
			delete $model_info_hsh_ref->{$model_ID}{$key} if exists $model_info_hsh_ref->{$model_ID}{$key};
		}
	}

	return ();
}
sub currentTime {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: printStartOrFinishMessage|1244, reportAndLogStatus|1613
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_defineout_dirPath|105, 3_process|135, 4_finishingTasks|162
#	input: none
#	output: $runTime
#	toCall: my ($runTime) = &currentTime();
#	calledInLine: 78, 1260, 1264, 1269, 1273, 1629, 1630
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $runTime = sprintf "%04d-%02d-%02d %02d:%02d", $year+1900, $mon+1,$mday,$hour,$min;	
	
	return $runTime;
}
sub deepAmendHash {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: processPerChromosome|1332
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_process|135
#	input: $amend_hsh_ref, $source_hsh_ref
#	output: 
#	toCall: &deepAmendHash($source_hsh_ref, $amend_hsh_ref);
#	calledInLine: 466, 1457
#....................................................................................................................................................#

	my ($source_hsh_ref, $amend_hsh_ref) = @_;

	foreach my $key (keys %{$source_hsh_ref}) {
		if (ref $source_hsh_ref->{$key} eq 'HASH') {
			# Recursively copy nested hash
			$amend_hsh_ref->{$key} = {};
			&deepAmendHash($source_hsh_ref->{$key}, $amend_hsh_ref->{$key});#->448
		} else {
			# Copy scalar values
			$amend_hsh_ref->{$key} = $source_hsh_ref->{$key};
		}
	}

	return ();
}
sub defineChainAndAssignGene {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: aggregateModel|203, assignNewGeneIDInChain|241, assignRefGeneIDInRefChainUsingBoundStringFromNonRefModels|309, assignRefGeneIDInRefChainUsingBoundStringFromRefModels|358, reportAndLogStatus|1613
#	appearInSub: processPerChromosome|1332
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_process|135
#	input: $chrom, $chrom_num, $disable_ref_chain_bound_gene_anno, $g_assign_hsh_ref, $gene_info_hsh_ref, $locus_info_hsh_ref, $model_info_hsh_ref, $novel_gene_prefix, $report_tag
#	output: $chain_info_hsh_ref, $gene_num
#	toCall: my ($chain_info_hsh_ref, $gene_num) = &defineChainAndAssignGene($locus_info_hsh_ref, $model_info_hsh_ref, $report_tag, $chrom_num, $novel_gene_prefix, $gene_info_hsh_ref, $g_assign_hsh_ref, $chrom, $disable_ref_chain_bound_gene_anno);
#	calledInLine: 1403
#....................................................................................................................................................#
	my ($locus_info_hsh_ref, $model_info_hsh_ref, $report_tag, $chrom_num, $novel_gene_prefix, $gene_info_hsh_ref, $g_assign_hsh_ref, $chrom, $disable_ref_chain_bound_gene_anno) = @_;
	
	my $num_locus = 0;
	my $chain_info_hsh_ref = {};
	my $chain_num = 0;
	my $gene_num = 0;
	foreach my $locus_ID (keys %{$locus_info_hsh_ref}) {
		my $strand = $locus_info_hsh_ref->{$locus_ID}{'strand'};
		my $bound_str_hsh_ref = {};
		my $exon_cluster_hsh_ref = {};
		foreach my $model_ID (@{$locus_info_hsh_ref->{$locus_ID}{'MD'}}) {
			foreach my $cluster_ID (@{$model_info_hsh_ref->{$model_ID}{'CL'}}) {
				push @{$exon_cluster_hsh_ref->{$cluster_ID}}, $model_ID;
			}
		}
		my $exclude_hit_hsh_ref = {};
		foreach my $seed_model_ID (@{$locus_info_hsh_ref->{$locus_ID}{'MD'}}) {
			next if exists $exclude_hit_hsh_ref->{$seed_model_ID};
			$chain_num++;
			my $chain_ID = "C".$chrom_num.$chain_num;
			my $all_hit_hsh_ref = {};
			my @rng_ary = ();
			my $cluster_key = 'CL';
			($all_hit_hsh_ref) = &aggregateModel($all_hit_hsh_ref, $seed_model_ID, $model_info_hsh_ref, $exon_cluster_hsh_ref, $exclude_hit_hsh_ref, $cluster_key);#->203

			foreach my $hit_model_ID (keys %{$all_hit_hsh_ref}) {
				$exclude_hit_hsh_ref->{$hit_model_ID}++;
				push @{$chain_info_hsh_ref->{$chain_ID}{'MD'}}, $hit_model_ID;
				$model_info_hsh_ref->{$hit_model_ID}{'CN'} = $chain_ID;
				my $chromStart = ${$model_info_hsh_ref->{$hit_model_ID}{'bed'}}[1];
				my $chromEnd = ${$model_info_hsh_ref->{$hit_model_ID}{'bed'}}[2];
				push @rng_ary, ($chromStart, $chromEnd);
				if (exists $model_info_hsh_ref->{$hit_model_ID}{'gene_ID'}) {
					my $gene_ID = $model_info_hsh_ref->{$hit_model_ID}{'gene_ID'};
					push @{$chain_info_hsh_ref->{$chain_ID}{'ref_gene_ID'}}, $gene_ID if (!grep { $_ eq $gene_ID } @{$chain_info_hsh_ref->{$chain_ID}{'ref_gene_ID'}});
					push @{$chain_info_hsh_ref->{$chain_ID}{'gene_ID'}}, $gene_ID if (!grep { $_ eq $gene_ID } @{$chain_info_hsh_ref->{$chain_ID}{'gene_ID'}});
				}
			}
			@rng_ary = sort {$a <=> $b} @rng_ary;
			my ($chromStart, $chromEnd) = ($rng_ary[0], $rng_ary[-1]);
			$chain_info_hsh_ref->{$chain_ID}{'chrom'} = $chrom;
			$chain_info_hsh_ref->{$chain_ID}{'strand'} = $strand;
			$chain_info_hsh_ref->{$chain_ID}{'rng'} = [$chromStart, $chromEnd];
			#---[2023/08/04 14:29] novel chain
			if (exists $chain_info_hsh_ref->{$chain_ID}{'ref_gene_ID'}) {
				&assignRefGeneIDInRefChainUsingBoundStringFromRefModels($all_hit_hsh_ref, $model_info_hsh_ref, $gene_info_hsh_ref, $g_assign_hsh_ref);#->358
				if ($disable_ref_chain_bound_gene_anno eq 'no') {
					&assignRefGeneIDInRefChainUsingBoundStringFromNonRefModels($all_hit_hsh_ref, $model_info_hsh_ref, $gene_info_hsh_ref, $g_assign_hsh_ref);#->309
				}
			} else {
				my $g_assign = $g_assign_hsh_ref->{'04'};
				($gene_num) = &assignNewGeneIDInChain($gene_num, $novel_gene_prefix, $chrom_num, $gene_info_hsh_ref, $chain_info_hsh_ref, $model_info_hsh_ref, $all_hit_hsh_ref, $g_assign, $chain_ID);#->241
			}
		}
		$num_locus++;
		&reportAndLogStatus("$report_tag Assigning gene in locus >>> $num_locus locus processed", 10, "\n") if $num_locus%10==0;#->1613
	}
	&reportAndLogStatus("$report_tag Finished assigning gene in locus >>> $num_locus locus processed", 10, "\n");#->1613

	return ($chain_info_hsh_ref, $gene_num);
}
sub defineChromInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1613
#	appearInSub: >none
#	primaryAppearInSection: 3_process|135
#	secondaryAppearInSection: >none
#	input: $chrom_size_path, $result_tmp_dir
#	output: $chrom_info_hsh_ref
#	toCall: my ($chrom_info_hsh_ref) = &defineChromInfo($chrom_size_path, $result_tmp_dir);
#	calledInLine: 147
#....................................................................................................................................................#
	my ($chrom_size_path, $result_tmp_dir) = @_;
	
	my $chrom_info_hsh_ref = {};
	&reportAndLogStatus("Reading chromosome size", 10, "\n");#->1613
	
	open (CHROMSIZE, "<", $chrom_size_path);
	while (<CHROMSIZE>) {
		chomp;
		my ($chrom, $size) = split /\t/;
		#next if $chrom ne 'chr1' and $chrom ne 'chr3' and $chrom ne 'chr5';
		#next if $chrom ne 'chr7';
		my $chrom_num = $chrom;
		$chrom_num =~ s/chr//;
		$chrom_num = 23 if $chrom_num =~ m/^X/;
		$chrom_num = 24 if $chrom_num eq 'Y';
		$chrom_num = 25 if $chrom_num eq 'M';
		$chrom_num = sprintf "%.2d", $chrom_num;
		my $chrom_dir = "$result_tmp_dir/$chrom";
		system ("mkdir -pm 755 $chrom_dir");
		my $tmp_txt = "$chrom_dir/$chrom.tmp.txt";
		my $ref_gene_exon_bed = "$chrom_dir/$chrom.ref_gene_exon.bed.bgz";
		my $exon_cluster_bed = "$chrom_dir/$chrom.exon_cluster.bed.bgz";
		my $orhpan_exon_cluster_bed = "$chrom_dir/$chrom.orhpan_exon_cluster.bed.bgz";
		my $log_txt = "$chrom_dir/$chrom.log.txt";

		$chrom_info_hsh_ref->{$chrom}{'size'} = $size;
		$chrom_info_hsh_ref->{$chrom}{'chrom_num'} = $chrom_num;
		$chrom_info_hsh_ref->{$chrom}{'tmp_txt'} = $tmp_txt;
		$chrom_info_hsh_ref->{$chrom}{'log_txt'} = $log_txt;
		$chrom_info_hsh_ref->{$chrom}{'ref_gene_exon_bed'} = $ref_gene_exon_bed;
		$chrom_info_hsh_ref->{$chrom}{'exon_cluster_bed'} = $exon_cluster_bed;
		$chrom_info_hsh_ref->{$chrom}{'orhpan_exon_cluster_bed'} = $orhpan_exon_cluster_bed;
		
		&reportAndLogStatus("chrom $chrom [#$chrom_num] = $size nt", 10, "\n");#->1613
	}
	close CHROMSIZE;

	return ($chrom_info_hsh_ref);
}
sub defineExonCluster {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1613
#	appearInSub: processPerChromosome|1332
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_process|135
#	input: $bedtools_bin, $bgzip_bin, $chrom, $exon_cluster_bed, $exon_overlap_dist, $model_bed_bgz, $model_info_hsh_ref, $report_tag, $tabix_bin
#	output: 
#	toCall: &defineExonCluster($bedtools_bin, $model_bed_bgz, $chrom, $report_tag, $model_info_hsh_ref, $exon_overlap_dist, $tabix_bin, $exon_cluster_bed, $bgzip_bin);
#	calledInLine: 1394
#....................................................................................................................................................#
	my ($bedtools_bin, $model_bed_bgz, $chrom, $report_tag, $model_info_hsh_ref, $exon_overlap_dist, $tabix_bin, $exon_cluster_bed, $bgzip_bin) = @_;

	system "$tabix_bin $model_bed_bgz $chrom | $bedtools_bin bed12tobed6 -i stdin | sort -k2,2n -k6,6 | $bedtools_bin cluster -s -d $exon_overlap_dist -i stdin | sort -k2,2n -k6,6 | $bgzip_bin -c >$exon_cluster_bed";
	open EXONCLUSTER, "$bgzip_bin -dc $exon_cluster_bed | cut -f 2,3,4,7 |";
	my $num_proc = 0;
	while (<EXONCLUSTER>) {
		chomp;
		$num_proc++;
		my ($chromStart, $chromEnd, $model_ID, $cluster_ID) = split /\t/;
		die if not exists $model_info_hsh_ref->{$model_ID};
		my $exon_length = $chromEnd - $chromStart;
		push @{$model_info_hsh_ref->{$model_ID}{'CL'}}, $cluster_ID;
		$model_info_hsh_ref->{$model_ID}{'EL'} += $exon_length;
		&reportAndLogStatus("$report_tag Defining exon clusters >>> $num_proc exons processed", 10, "\n") if $num_proc%1000000==0;#->1613
	}
	close EXONCLUSTER;
	
	&reportAndLogStatus("$report_tag Finished defining exon clusters ### $num_proc exons processed", 10, "\n");#->1613

	return ();
}
sub defineLocus {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1613
#	appearInSub: processPerChromosome|1332
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_process|135
#	input: $bedtools_bin, $chrom, $chrom_num, $locus_merge_dist, $model_bed_bgz, $model_info_hsh_ref, $report_tag, $tabix_bin
#	output: $locus_info_hsh_ref
#	toCall: my ($locus_info_hsh_ref) = &defineLocus($tabix_bin, $bedtools_bin, $model_bed_bgz, $chrom, $model_info_hsh_ref, $report_tag, $locus_merge_dist, $chrom_num);
#	calledInLine: 1400
#....................................................................................................................................................#
	my ($tabix_bin, $bedtools_bin, $model_bed_bgz, $chrom, $model_info_hsh_ref, $report_tag, $locus_merge_dist, $chrom_num) = @_;
	
	my $locus_info_hsh_ref = {};
	
	my $num_locus = 0;
	open LOCUSBED, "$tabix_bin $model_bed_bgz $chrom | cut -f 1,2,3,4,5,6 | $bedtools_bin merge -c 4,5,6 -o collapse,count,distinct -s -d $locus_merge_dist -i stdin |";
	while (<LOCUSBED>) {
		chomp;
		my (undef, $chromStart, $chromEnd, $model_ID_str, undef, $strand) = split /\t/;
		$num_locus++;
		my $locus_ID = 'L'.$chrom_num.$num_locus;
		$locus_info_hsh_ref->{$locus_ID}{'rng'} = [$chromStart, $chromEnd];
		$locus_info_hsh_ref->{$locus_ID}{'strand'} = $strand;
		foreach my $model_ID (split /,/, $model_ID_str) {
			push @{$locus_info_hsh_ref->{$locus_ID}{'MD'}}, $model_ID;
			$model_info_hsh_ref->{$model_ID}{'LS'} = $locus_ID;
		}
		#&reportAndLogStatus("$report_tag Defining locus >>> $num_locus locus defined", 10, "\n") if $num_locus%1000==0;#->1613
	}
	close LOCUSBED;
	$num_locus = int($num_locus);
	&reportAndLogStatus("$report_tag Finished defining locus ### $num_locus locus defined", 10, "\n");#->1613
	
	return ($locus_info_hsh_ref);
}
sub defineOrphanExonCluster {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1613
#	appearInSub: processPerChromosome|1332
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_process|135
#	input: $bedtools_bin, $bgzip_bin, $exon_cluster_bed, $exon_overlap_dist, $model_info_hsh_ref, $orhpan_exon_cluster_bed, $report_tag
#	output: 
#	toCall: &defineOrphanExonCluster($model_info_hsh_ref, $exon_cluster_bed, $orhpan_exon_cluster_bed, $bgzip_bin, $bedtools_bin, $exon_overlap_dist, $report_tag);
#	calledInLine: 1406
#....................................................................................................................................................#
	my ($model_info_hsh_ref, $exon_cluster_bed, $orhpan_exon_cluster_bed, $bgzip_bin, $bedtools_bin, $exon_overlap_dist, $report_tag) = @_;
	
	open EXONCLUSTER, "$bgzip_bin -dc $exon_cluster_bed |";
	open ORPHANEXONCLUSTER, "| $bedtools_bin cluster -s -d $exon_overlap_dist -i stdin | sort -k2,2n -k6,6 | $bgzip_bin -c >$orhpan_exon_cluster_bed";
	while (<EXONCLUSTER>) {
		chomp;
		my ($chrom, $chromStart, $chromEnd, $model_ID, $score, $strand) = split /\t/;
		die if not exists $model_info_hsh_ref->{$model_ID};
		next if exists $model_info_hsh_ref->{$model_ID}{'gene_ID'}; #---[2023/08/04 19:14] only for orhpans
		print ORPHANEXONCLUSTER join "", (join "\t", ($chrom, $chromStart, $chromEnd, $model_ID, $score, $strand)), "\n";
	}
	close ORPHANEXONCLUSTER;
	close EXONCLUSTER;
	
	open ORPHANEXONCLUSTER, "$bgzip_bin -dc $orhpan_exon_cluster_bed | cut -f 4,7 |";
	my $num_proc = 0;
	while (<ORPHANEXONCLUSTER>) {
		chomp;
		$num_proc++;
		my ($model_ID, $orphan_cluster_ID) = split /\t/;
		die if not exists $model_info_hsh_ref->{$model_ID};
		push @{$model_info_hsh_ref->{$model_ID}{'OCL'}}, $orphan_cluster_ID;
		&reportAndLogStatus("$report_tag Defining orphan exon clusters >>> $num_proc exons processed", 10, "\n") if $num_proc%1000000==0;#->1613
	}
	close ORPHANEXONCLUSTER;
	
	&reportAndLogStatus("$report_tag Finished defining orphan exon clusters ### $num_proc exons processed", 10, "\n");#->1613

	return ();
}
sub defineRefGeneExon {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: processPerChromosome|1332
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_process|135
#	input: $bedtools_bin, $bgzip_bin, $exclude_t_type, $model_info_hsh_ref, $ref_gene_exon_bed, $tabix_bin
#	output: 
#	toCall: &defineRefGeneExon($ref_gene_exon_bed, $bgzip_bin, $model_info_hsh_ref, $tabix_bin, $bedtools_bin, $exclude_t_type);
#	calledInLine: 1391
#....................................................................................................................................................#
	my ($ref_gene_exon_bed, $bgzip_bin, $model_info_hsh_ref, $tabix_bin, $bedtools_bin, $exclude_t_type) = @_;
	
	my $exclude_t_type_hsh_ref = {};
	if (defined $exclude_t_type) {
		foreach my $t_type (split /,/, $exclude_t_type) {
			$exclude_t_type_hsh_ref->{$t_type}++;
		}
	}
	
	#---[2023/08/03 21:22] put the gene in the first column of the bed to make gene based collapse
	my $awk_cmd = 'awk -F\'\t\' \'BEGIN {OFS=FS} {temp=$1; $1=$4; $4=temp; print}\'';#---[2023/08/03 21:20]  switch the 4th and 1st column
	open BEDTOOLS, "| $bedtools_bin bed12tobed6 -i stdin | sort -k1,1 -k2,2n | $bedtools_bin merge -s -c 4,5,6 -o distinct,count,distinct -i stdin | sort -k2,2n -k6,6 |".$awk_cmd."| $bgzip_bin -c >$ref_gene_exon_bed";
	foreach my $model_ID (keys %{$model_info_hsh_ref}) {
		if (exists $model_info_hsh_ref->{$model_ID}{'gene_ID'}) {
			my $gene_ID = $model_info_hsh_ref->{$model_ID}{'gene_ID'};
			my $t_type = $model_info_hsh_ref->{$model_ID}{'t_type'};
			next if exists $exclude_t_type_hsh_ref->{$t_type};
			my ($chrom, $chromStart, $chromEnd, $model_ID, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts) = @{$model_info_hsh_ref->{$model_ID}{'bed'}};
			print BEDTOOLS join "", (join "\t", ($gene_ID, $chromStart, $chromEnd, $chrom, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts)), "\n";
		}
	}
	close BEDTOOLS;

	return ();
}
sub getModelBoundStr {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1613
#	appearInSub: processPerChromosome|1332
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_process|135
#	input: $model_info_gz, $model_info_hsh_ref, $report_tag
#	output: 
#	toCall: &getModelBoundStr($model_info_hsh_ref, $model_info_gz, $report_tag);
#	calledInLine: 1385
#....................................................................................................................................................#
	my ($model_info_hsh_ref, $model_info_gz, $report_tag) = @_;
	
	my $num_proc = 0;
	open MODELINFO, "gzip -dc $model_info_gz |";
	<MODELINFO>;
	while (<MODELINFO>) {
		#model_ID	loc	completeness	full_set_ID	end5_conf	end3_conf	junct_conf	end5_endtype	end3_endtype	novelty	strand	partial_set_count	partial_set_ID_str	full_ref_count	full_qry_count	partial_ref_count	partial_qry_count	full_set_bound_str
		chomp;
		my ($model_ID, $loc, $completeness, $full_set_ID, $end5_conf, $end3_conf, $junct_conf, $end5_endtype, $end3_endtype, $novelty, $strand, $partial_set_count, $partial_set_ID_str, $full_ref_count, $full_qry_count, $partial_ref_count, $partial_qry_count, $full_set_bound_str) = split /\t/;
		next if not exists $model_info_hsh_ref->{$model_ID};
		$num_proc++;
		$full_set_bound_str =~ s/_\+|\-//;
		@{$model_info_hsh_ref->{$model_ID}{'BS'}} = split /_/, $full_set_bound_str;
		my $exon_num = @{$model_info_hsh_ref->{$model_ID}{'BS'}} - 1;
		$model_info_hsh_ref->{$model_ID}{'EN'} = $exon_num;
		$model_info_hsh_ref->{$model_ID}{'info'} = [$completeness, $full_ref_count, $full_qry_count, $partial_ref_count, $partial_qry_count];
		&reportAndLogStatus("$report_tag Reading model bound string >>> $num_proc models stored", 10, "\n") if $num_proc%50000==0;#->1613
	}
	close MODELINFO;
	
	foreach my $model_ID (keys %{$model_info_hsh_ref}) {
		die "$model_ID does have bound string\n" if not exists $model_info_hsh_ref->{$model_ID}{'BS'};
	}
	
	&reportAndLogStatus("$report_tag Finished reading model bound string ### all models have bound string", 10, "\n");#->1613
	
	return ();
}
sub getModelInChrom {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1613
#	appearInSub: processPerChromosome|1332
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_process|135
#	input: $bedtools_bin, $chrom, $model_bed_bgz, $report_tag, $revert_ref_model_bed_bgz, $tabix_bin
#	output: $model_info_hsh_ref
#	toCall: my ($model_info_hsh_ref) = &getModelInChrom($tabix_bin, $bedtools_bin, $model_bed_bgz, $revert_ref_model_bed_bgz, $chrom, $report_tag);
#	calledInLine: 1382
#....................................................................................................................................................#
	my ($tabix_bin, $bedtools_bin, $model_bed_bgz, $revert_ref_model_bed_bgz, $chrom, $report_tag) = @_;

	my $model_info_hsh_ref = {};
	open MODELBED, "$tabix_bin $model_bed_bgz $chrom | ";
	while (<MODELBED>) {
		chomp;
		my ($chrom, $chromStart, $chromEnd, $model_ID, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts) = split /\t/;
		#$model_info_hsh_ref->{$model_ID}{'score'} = $score;
		$model_info_hsh_ref->{$model_ID}{'bed'} = [$chrom, $chromStart, $chromEnd, $model_ID, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts];
		$model_info_hsh_ref->{$model_ID}{'revert'} = 'N';
		$model_info_hsh_ref->{$model_ID}{'ref'} = 'N';
	}
	close MODELBED;
	my $num_model = keys %{$model_info_hsh_ref};
	&reportAndLogStatus("$report_tag Finished reading model bed ### $num_model models stored", 10, "\n");#->1613

	if (defined $revert_ref_model_bed_bgz and -s $revert_ref_model_bed_bgz) {
		my $num_revert = 0;
		&reportAndLogStatus("$report_tag Reverting model bed", 10, "\n");#->1613
		open MODELBED, "$tabix_bin $revert_ref_model_bed_bgz $chrom | ";
		while (<MODELBED>) {
			chomp;
			my ($chrom, $chromStart, $chromEnd, $model_ID, undef, $strand, $thickStart, $thickEnd, undef, $blockCount, $blockSizes, $blockStarts) = split /\t/;
			#$model_info_hsh_ref->{$model_ID}{'score'} = $score;
			next if not exists $model_info_hsh_ref->{$model_ID};
			my $score = $model_info_hsh_ref->{$model_ID}{'bed'}[4];
			my $itemRgb = $model_info_hsh_ref->{$model_ID}{'bed'}[8];
			if ($score == 0) {
				$num_revert++;
				$model_info_hsh_ref->{$model_ID}{'bed'} = [$chrom, $chromStart, $chromEnd, $model_ID, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts];
				$model_info_hsh_ref->{$model_ID}{'revert'} = 'Y';
			}
		}
		close MODELBED;
		&reportAndLogStatus("$report_tag Finished reverting model bed ### $num_revert models reverted", 10, "\n");#->1613
	}

	return ($model_info_hsh_ref);
}
sub intersectModelWithRefExon {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: assignRefGeneIDByExonOverlap|269, reportAndLogStatus|1613
#	appearInSub: processPerChromosome|1332
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_process|135
#	input: $bedtools_bin, $chrom, $exon_cluster_bed, $g_assign_hsh_ref, $min_ref_exon_overlap_pct, $model_info_hsh_ref, $ref_gene_exon_bed, $report_tag
#	output: 
#	toCall: &intersectModelWithRefExon($bedtools_bin, $chrom, $report_tag, $model_info_hsh_ref, $ref_gene_exon_bed, $exon_cluster_bed, $g_assign_hsh_ref, $min_ref_exon_overlap_pct);
#	calledInLine: 1397
#....................................................................................................................................................#
	my ($bedtools_bin, $chrom, $report_tag, $model_info_hsh_ref, $ref_gene_exon_bed, $exon_cluster_bed, $g_assign_hsh_ref, $min_ref_exon_overlap_pct) = @_;
	
	my $ovrlp_hsh_ref = {};
	my $num_proc = 0;
	open INTERSECT, "$bedtools_bin intersect -s -sorted -wo -a $exon_cluster_bed -b $ref_gene_exon_bed | cut -f 4,11,14 |";
	while (<INTERSECT>) {
		chomp;
		my ($model_ID, $gene_ID, $ovrlp_nt) = split /\t/;
		$ovrlp_hsh_ref->{$model_ID}{$gene_ID} += $ovrlp_nt;
		$num_proc++;
		&reportAndLogStatus("$report_tag Intersecting Ref exon >>> $num_proc exon processed", 10, "\n") if $num_proc%100000==0;#->1613
	}
	close INTERSECT;
	&reportAndLogStatus("$report_tag Finished intersecting Ref exon ### $num_proc exon processed", 10, "\n");#->1613
	
	foreach my $model_ID (keys %{$ovrlp_hsh_ref}) {
		my $exon_length = $model_info_hsh_ref->{$model_ID}{'EL'};
		my $max_ovrlp_gene_ID = undef;
		my $max_ovrlp_pct = 0;
		foreach my $gene_ID (keys %{$ovrlp_hsh_ref->{$model_ID}}) {
			my $ovrlp_nt = $ovrlp_hsh_ref->{$model_ID}{$gene_ID};
			my $ovrlp_pct = 100*($ovrlp_nt/$exon_length);
			$model_info_hsh_ref->{$model_ID}{'OL'}{$gene_ID} = $ovrlp_nt;
			if ($ovrlp_pct > $max_ovrlp_pct) {
				$max_ovrlp_gene_ID = $gene_ID;
				$max_ovrlp_pct = $ovrlp_pct;
			}
		}
		
		if (not exists $model_info_hsh_ref->{$model_ID}{'gene_ID'} and defined $max_ovrlp_gene_ID and $max_ovrlp_pct >= $min_ref_exon_overlap_pct) {
			my $gene_ID = $max_ovrlp_gene_ID;
			&assignRefGeneIDByExonOverlap($model_ID, $gene_ID, $model_info_hsh_ref, $g_assign_hsh_ref);#->269
		}
	}
	
	return ();
}
sub logCalledCMDAndScript {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 2_defineout_dirPath|105
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $result_script_dir, $scriptAbsPath
#	output: 
#	toCall: &logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);
#	calledInLine: 117
#....................................................................................................................................................#
	my ($ARGVStr, $result_script_dir, $scriptAbsPath) = @_;


	my $cpScriptPath = "$result_script_dir/script.ran.pl";
	my $calledCMDPath = "$result_script_dir/called.cmd.txt";
	system "cp -f $scriptAbsPath $cpScriptPath";
	system "chmod 0444 $cpScriptPath"; #---[07/03/2014 18:02] make it read-only to make sure there'll be accodental change of parameters
	open CALLEDCMD, ">", $calledCMDPath;
	print CALLEDCMD join "", ($ARGVStr), "\n";
	close CALLEDCMD;
	
	return ();
}
sub printChainInfoAndBed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1613
#	appearInSub: >none
#	primaryAppearInSection: 3_process|135
#	secondaryAppearInSection: >none
#	input: $bgzip_bin, $chain_info_hsh_ref, $gene_info_hsh_ref, $paramTag, $result_bed_dir, $result_log_dir, $tabix_bin
#	output: 
#	toCall: &printChainInfoAndBed($result_log_dir, $paramTag, $chain_info_hsh_ref, $gene_info_hsh_ref, $result_bed_dir, $bgzip_bin, $tabix_bin);
#	calledInLine: 154
#....................................................................................................................................................#
	my ($result_log_dir, $paramTag, $chain_info_hsh_ref, $gene_info_hsh_ref, $result_bed_dir, $bgzip_bin, $tabix_bin) = @_;
	
	my $chain_log_path = "$result_log_dir/$paramTag.chain.info.tsv.gz";
	my $chain_bed_path = "$result_bed_dir/$paramTag.chain.bed.bgz";
	my $num_proc = 0;
	open CHAINBED , "| sort -k1,1 -k2,2n | $bgzip_bin -c >$chain_bed_path";
	open CHAININFO , "| gzip -c >$chain_log_path";

	print CHAININFO join "", (join "\t", ('chain_ID', 'loc', 'strand', 'total_qry_count', 'model_num', 'gene_num', 'ref_gene_num', 'gene_name_str', 'g_type_str', 'gene_ID_str', 'ref_gene_ID_str', 'model_ID_str')), "\n";
	foreach my $chain_ID (sort keys %{$chain_info_hsh_ref}) {
		my $ref_gene_ID_str = '__na';
		my $ref_gene_num = 0;
		if (exists $chain_info_hsh_ref->{$chain_ID}{'ref_gene_ID'}) {
			$ref_gene_ID_str = join ";", sort @{$chain_info_hsh_ref->{$chain_ID}{'ref_gene_ID'}};
			$ref_gene_num = @{$chain_info_hsh_ref->{$chain_ID}{'ref_gene_ID'}};
		}
		my $gene_ID_str = join ";", sort @{$chain_info_hsh_ref->{$chain_ID}{'gene_ID'}};
		my $model_ID_str = join ";",sort @{$chain_info_hsh_ref->{$chain_ID}{'MD'}};
		my $gene_num = @{$chain_info_hsh_ref->{$chain_ID}{'gene_ID'}};
		my $model_num = @{$chain_info_hsh_ref->{$chain_ID}{'MD'}};
		my @gene_name_ary = ();
		my @g_type_ary = ();
		my $total_qry_count = 0;
		foreach my $gene_ID (sort @{$chain_info_hsh_ref->{$chain_ID}{'gene_ID'}}) {
			$total_qry_count += $gene_info_hsh_ref->{$gene_ID}{'QC'};
			push @gene_name_ary, $gene_info_hsh_ref->{$gene_ID}{'gene_name'};
			push @g_type_ary, $gene_info_hsh_ref->{$gene_ID}{'g_type'};
		}
		my $gene_name_str = join ";", @gene_name_ary;
		my $g_type_str = join ";", @g_type_ary;

		my $chrom = $chain_info_hsh_ref->{$chain_ID}{'chrom'};
		my $strand = $chain_info_hsh_ref->{$chain_ID}{'strand'};
		my ($chromStart, $chromEnd) = @{$chain_info_hsh_ref->{$chain_ID}{'rng'}}; 
		my $loc = $chrom.":".$chromStart.'-'.$chromEnd;
		
		my $itemRgb = '228,26,28';
		$itemRgb = '55,126,184' if ($strand eq '-');

		my $ID_string = join "|", ($chain_ID, "model=".$model_num, "gene=".$gene_num, $gene_name_str);
		my $score = $total_qry_count;
		my $thickStart = $chromStart;
		my $thickEnd = $chromEnd;
		my $blockCount = 1;
		my $blockSizes = $chromEnd - $chromStart;
		my $blockStarts = 0;
		print CHAINBED join "", (join "\t", ($chrom, $chromStart, $chromEnd, $ID_string, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts)), "\n";
		print CHAININFO join "", (join "\t", ($chain_ID, $loc, $strand, $total_qry_count, $model_num, $gene_num, $ref_gene_num, $gene_name_str, $g_type_str, $gene_ID_str, $ref_gene_ID_str, $model_ID_str)), "\n";
		$num_proc++;
		&reportAndLogStatus("Printing chain info and bed >>> $num_proc chains printed", 10, "\n") if $num_proc%10000==0;#->1613
	}
	
	close CHAINBED;
	close CHAININFO;

	&reportAndLogStatus("Finshed printing chain info and bed ### $num_proc chains printed", 10, "\n");#->1613

	&reportAndLogStatus("Indexing chain_bed_path ......", 10, "\n");#->1613
	system ("$tabix_bin -p bed $chain_bed_path");
		

	return ();
}
sub printGeneInfoAndBed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1613
#	appearInSub: >none
#	primaryAppearInSection: 3_process|135
#	secondaryAppearInSection: >none
#	input: $bgzip_bin, $gene_info_hsh_ref, $paramTag, $result_bed_dir, $result_log_dir, $tabix_bin
#	output: 
#	toCall: &printGeneInfoAndBed($result_log_dir, $paramTag, $gene_info_hsh_ref, $result_bed_dir, $bgzip_bin, $tabix_bin);
#	calledInLine: 152
#....................................................................................................................................................#
	my ($result_log_dir, $paramTag, $gene_info_hsh_ref, $result_bed_dir, $bgzip_bin, $tabix_bin) = @_;
	
	my $gene_log_path = "$result_log_dir/$paramTag.gene.info.tsv.gz";
	my $gene_bed_path = "$result_bed_dir/$paramTag.gene.bed.bgz";
	my $num_proc = 0;
	open GENEBED , "| sort -k1,1 -k2,2n | $bgzip_bin -c >$gene_bed_path";
	open GENEINFO , "| gzip -c >$gene_log_path";

	my @g_assign_ary = ();
	foreach my $gene_ID (keys %{$gene_info_hsh_ref}) {
		@g_assign_ary = sort keys %{$gene_info_hsh_ref->{$gene_ID}{'GA'}};
		last;
	}
	print GENEINFO join "", (join "\t", ('gene_ID', 'loc', 'strand', 'gene_name', 'g_type', 'total_qry_count', 'model_num', 'complete_model_num', @g_assign_ary, 'chain_num', 'chain_ID_str', 'model_ID_str')), "\n";
	foreach my $gene_ID (sort keys %{$gene_info_hsh_ref}) {
		my $model_ID_str = join ";", @{$gene_info_hsh_ref->{$gene_ID}{'MD'}};
		my $chain_ID_str = join ";", @{$gene_info_hsh_ref->{$gene_ID}{'CN'}};
		my ($chromStart, $chromEnd) = @{$gene_info_hsh_ref->{$gene_ID}{'rng'}}; 
		my $strand = $gene_info_hsh_ref->{$gene_ID}{'ST'};
		my $chrom = $gene_info_hsh_ref->{$gene_ID}{'CH'};
		my $loc = $chrom.":".$chromStart.'-'.$chromEnd;
		my $g_type = $gene_info_hsh_ref->{$gene_ID}{'g_type'};
		my $gene_name = $gene_info_hsh_ref->{$gene_ID}{'gene_name'};
		my $complete_model_num = $gene_info_hsh_ref->{$gene_ID}{'CMD'};
		my $model_num = @{$gene_info_hsh_ref->{$gene_ID}{'MD'}};
		my $chain_num = @{$gene_info_hsh_ref->{$gene_ID}{'CN'}};
		my $total_qry_count = $gene_info_hsh_ref->{$gene_ID}{'QC'};
		my @g_assign_count_ary = ();
		foreach my $g_assign (@g_assign_ary) {
			push @g_assign_count_ary, $gene_info_hsh_ref->{$gene_ID}{'GA'}{$g_assign};
		}
		
		my $itemRgb = '228,26,28';
		$itemRgb = '55,126,184' if ($strand eq '-');

		my $ID_string = join "|", ($gene_ID, $gene_name, $g_type, $chain_ID_str);
		my $score = $total_qry_count;
		my $thickStart = $chromStart;
		my $thickEnd = $chromEnd;
		my $blockCount = 1;
		my $blockSizes = $chromEnd - $chromStart;
		my $blockStarts = 0;
		print GENEBED join "", (join "\t", ($chrom, $chromStart, $chromEnd, $ID_string, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts)), "\n";
		print GENEINFO join "", (join "\t", ($gene_ID, $loc, $strand, $gene_name, $g_type, $total_qry_count, $model_num, $complete_model_num, @g_assign_count_ary, $chain_num, $chain_ID_str, $model_ID_str)), "\n";
		$num_proc++;
		&reportAndLogStatus("Printing gene info and bed >>> $num_proc genes printed", 10, "\n") if $num_proc%10000==0;#->1613
	}
	
	close GENEBED;
	close GENEINFO;

	&reportAndLogStatus("Finshed printing gene info and bed ### $num_proc genes printed", 10, "\n");#->1613

	&reportAndLogStatus("Indexing gene_bed_path ......", 10, "\n");#->1613
	system ("$tabix_bin -p bed $gene_bed_path");
	
	return ();
}
sub printModelInfoAndBed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1613
#	appearInSub: >none
#	primaryAppearInSection: 3_process|135
#	secondaryAppearInSection: >none
#	input: $bgzip_bin, $gene_info_hsh_ref, $model_info_hsh_ref, $paramTag, $result_bed_dir, $result_log_dir, $tabix_bin
#	output: 
#	toCall: &printModelInfoAndBed($result_log_dir, $paramTag, $model_info_hsh_ref, $gene_info_hsh_ref, $result_bed_dir, $bgzip_bin, $tabix_bin);
#	calledInLine: 150
#....................................................................................................................................................#
	my ($result_log_dir, $paramTag, $model_info_hsh_ref, $gene_info_hsh_ref, $result_bed_dir, $bgzip_bin, $tabix_bin) = @_;
	
	my $model_gene_pair_log_path = "$result_log_dir/$paramTag.model_gene_pair.info.tsv.gz";
	my $model_log_path = "$result_log_dir/$paramTag.model.info.tsv.gz";
	my $model_bed_path = "$result_bed_dir/$paramTag.model.bed.bgz";
	my $num_proc = 0;
	open MODELBED , "| sort -k1,1 -k2,2n | $bgzip_bin -c >$model_bed_path";
	open MODELINFO , "| gzip -c >$model_log_path";
	open MODELGENE , "| gzip -c >$model_gene_pair_log_path";
	print MODELINFO join "", (join "\t", ('model_ID', 'loc', 'exon_length', 'exon_num', 'revert', 'g_assign', 'gene_ID', 'gene_name', 'g_type', 'chain_ID', 'locus_ID', 'completeness', 'full_ref_count', 'full_qry_count', 'partial_ref_count', 'partial_qry_count', 'full_set_bound_str')), "\n";
	print MODELGENE join "", (join "\t", ('model_ID', 'exon_length', 'ovrlp_nt', 'ovrlp_pct', 'is_model_gene_ID', 'ovrlp_gene_ID', 'ovrlp_gene_name', 'ovrlp_g_type')), "\n";
	foreach my $model_ID (sort keys %{$model_info_hsh_ref}) {
		my ($completeness, $full_ref_count, $full_qry_count, $partial_ref_count, $partial_qry_count) = @{$model_info_hsh_ref->{$model_ID}{'info'}};
		my ($chrom, $chromStart, $chromEnd, undef, $score, $strand, $thickStart, $thickEnd, undef, $blockCount, $blockSizes, $blockStarts) = @{$model_info_hsh_ref->{$model_ID}{'bed'}};
		my $full_set_bound_str = join "_", (@{$model_info_hsh_ref->{$model_ID}{'BS'}}, $strand);
		my $end3 = @{$model_info_hsh_ref->{$model_ID}{'BS'}}[-1];
		my $end5 = @{$model_info_hsh_ref->{$model_ID}{'BS'}}[0];
		my $loc = $chrom.":".$chromStart.'-'.$chromEnd;
		my $exon_length = $model_info_hsh_ref->{$model_ID}{'EL'};
		my $exon_num = $model_info_hsh_ref->{$model_ID}{'EN'};
		my $chain_ID = $model_info_hsh_ref->{$model_ID}{'CN'};
		my $locus_ID = $model_info_hsh_ref->{$model_ID}{'LS'};
		my $revert = $model_info_hsh_ref->{$model_ID}{'revert'};
		my $model_gene_ID = $model_info_hsh_ref->{$model_ID}{'gene_ID'};
		my $g_assign = $model_info_hsh_ref->{$model_ID}{'g_assign'};
		my $model_g_type = $gene_info_hsh_ref->{$model_gene_ID}{'g_type'};
		my $model_gene_name = $gene_info_hsh_ref->{$model_gene_ID}{'gene_name'};
		print MODELINFO join "", (join "\t", ($model_ID, $loc, $exon_length, $exon_num, $revert, $g_assign, $model_gene_ID, $model_gene_name, $model_g_type, $chain_ID, $locus_ID, $completeness, $full_ref_count, $full_qry_count, $partial_ref_count, $partial_qry_count, $full_set_bound_str)), "\n";
		
		my $itemRgb = '228,26,28';
		$itemRgb = '55,126,184' if ($strand eq '-');
		my $ID_string = join "|", ($model_ID, $model_gene_name, $g_assign, $end5, $end3, $model_gene_ID, $chain_ID);
		print MODELBED join "", (join "\t", ($chrom, $chromStart, $chromEnd, $ID_string, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts)), "\n";
		$num_proc++;
		&reportAndLogStatus("Printing model info and bed >>> $num_proc models printed", 10, "\n") if $num_proc%10000==0;#->1613

		next if not exists $model_info_hsh_ref->{$model_ID}{'OL'};
		foreach my $ovrlp_gene_ID (sort keys %{$model_info_hsh_ref->{$model_ID}{'OL'}}) {
			my $ovrlp_nt = $model_info_hsh_ref->{$model_ID}{'OL'}{$ovrlp_gene_ID};
			my $ovrlp_pct = sprintf "%.2f", 100*$ovrlp_nt/$exon_length;
			my $ovrlp_g_type = $gene_info_hsh_ref->{$ovrlp_gene_ID}{'g_type'};
			my $ovrlp_gene_name = $gene_info_hsh_ref->{$ovrlp_gene_ID}{'gene_name'};
			my $is_model_gene_ID = 'N';
			$is_model_gene_ID = "Y" if $ovrlp_gene_ID eq $model_gene_ID;
			print MODELGENE join "", (join "\t", ($model_ID, $exon_length, $ovrlp_nt, $ovrlp_pct, $is_model_gene_ID, $ovrlp_gene_ID, $ovrlp_gene_name, $ovrlp_g_type)), "\n";
		}
	}
	close MODELGENE;
	close MODELINFO;
	close MODELBED;

	&reportAndLogStatus("Finshed printing model info and bed ### $num_proc models printed", 10, "\n");#->1613

	&reportAndLogStatus("Indexing model_bed_path ......", 10, "\n");#->1613
	system ("$tabix_bin -p bed $model_bed_path");
	
	return ();
}
sub printOutputFileListAndReadme {
#....................................................................................................................................................#
#	subroutineCategory: output
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 4_finishingTasks|162
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $out_dir, $paramTag
#	output: 
#	toCall: &printOutputFileListAndReadme($ARGVStr, $paramTag, $out_dir);
#	calledInLine: 165
#....................................................................................................................................................#
	my ($ARGVStr, $paramTag, $out_dir) = @_;
	
	my $outputFileListPath = "$out_dir/$paramTag/output.file.list.txt";
	open (OUTFILELIST, ">", $outputFileListPath);

	my %dirHsh = ();
	my %filelistLenCountHsh = ();
	push @{$filelistLenCountHsh{'dir'}}, length 'Directory';
	push @{$filelistLenCountHsh{'name'}}, length 'Name';
	push @{$filelistLenCountHsh{'description'}}, length 'Description';
	
	foreach my $outputFilePath (sort {$a cmp $b} keys %{$globalReadmeHsh_ref}) {
		my $fileDescription =  $globalReadmeHsh_ref->{$outputFilePath}{'description'};
		my $cleandOutputFilePath = $outputFilePath;
		$cleandOutputFilePath =~ s/\/+/\//g;
		
		my ($filePrefix, $fileDir, $fileSuffix) = fileparse($cleandOutputFilePath, qr/\.[^.]*/);
		$fileDir =~ s/^$out_dir//;
		my $fileName = $filePrefix.$fileSuffix;
		$dirHsh{$fileDir}{$fileName} = $fileDescription;
		push @{$filelistLenCountHsh{'dir'}}, length $fileDir;
		push @{$filelistLenCountHsh{'name'}}, length $fileName;
		push @{$filelistLenCountHsh{'description'}}, length $fileDescription;
		
		open README, ">", "$outputFilePath.readme.txt";
		print README "=================\n";
		print README "File descriptions\n";
		print README "=================\n";
		print README "$fileDescription\n";
					
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}) {
			my @colLenCountHsh = (length 'column');
			push @colLenCountHsh, length $_ foreach (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}});
			my $headerColLen = max(@colLenCountHsh)+2;
			print README "\n";
			print README "\n";
			print README "===================\n";
			print README "Column descriptions\n";
			print README "===================\n";
			print README "\n";
			printf README "%-".$headerColLen."s", 'column';
			print README "description\n";
			printf README "%-".$headerColLen."s", '------';
			print README "-----------\n";
			foreach my $header (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}}) {
				my $columnDescription = 'self-explanatory';
				$columnDescription = $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header} if exists $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header};
				printf README "%-".$headerColLen."s", $header;
				print README $columnDescription."\n";
			}
		}
		
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}) {
			print README "\n";
			print README "\n";
			print README "=================\n";
			print README "Extra information\n";
			print README "=================\n";
			print README "\n";
			foreach my $title (sort keys %{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}}) {
				print README "$title\n";
				print README "-" foreach (1..length $title);
				print README "\n";
				print README "$_\n" foreach @{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}{$title}};
			}
		}
		
		print README "\n";
		print README "\n";
		print README "~" foreach (1..length "$fileName was created from running,");
		print README "\n";
		print README "$fileName was created from running,\n";
		print README "\n";
		print README "$ARGVStr\n";
		print README "\n";
		close README;
	}

	my $fileDir_colLen = max(@{$filelistLenCountHsh{'dir'}})+2;
	my $fileName_colLen = max(@{$filelistLenCountHsh{'name'}})+2;
	my $fileDescription_colLen = max(@{$filelistLenCountHsh{'description'}})+2;
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", 'directory', 'name', 'description');
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", '=========', '====', '===========');
	foreach my $fileDir (sort {$a cmp $b} keys %dirHsh) {
		foreach my $fileName (sort {$a cmp $b} keys %{$dirHsh{$fileDir}}) {
			my $fileDescription = $dirHsh{$fileDir}{$fileName};	
			printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", $fileDir, $fileName, $fileDescription);
		}
	}
	
	print OUTFILELIST "\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "~" foreach (1..length "The above files were generated by running,");
	print OUTFILELIST "\n";
	print OUTFILELIST "The above files were generated by running,\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "$ARGVStr\n";
	print OUTFILELIST "\n";

	close OUTFILELIST;

	return ();
}
sub printStartOrFinishMessage {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: currentTime|430
#	appearInSub: >none
#	primaryAppearInSection: 2_defineout_dirPath|105, 4_finishingTasks|162
#	secondaryAppearInSection: >none
#	input: $StartOrFinishMessage
#	output: none
#	toCall: &printStartOrFinishMessage($StartOrFinishMessage);
#	calledInLine: 118, 166
#....................................................................................................................................................#

	my ($StartOrFinishMessage) = @_;
	
	if ($StartOrFinishMessage eq "startMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] starts running ...... \n";#->430
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] starts running ...... \n";#->430
		print $tmplog_fh "=========================================================================\n\n";

	} elsif ($StartOrFinishMessage eq "finishMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] finished running .......\n";#->430
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] finished running .......\n";#->430
		print $tmplog_fh "=========================================================================\n\n";
	}
}
sub processOrphanModel {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: aggregateModel|203, assignNewGeneIDInChain|241, reportAndLogStatus|1613
#	appearInSub: processPerChromosome|1332
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_process|135
#	input: $chain_info_hsh_ref, $chrom_num, $g_assign_hsh_ref, $gene_info_hsh_ref, $gene_num, $model_info_hsh_ref, $novel_gene_prefix, $report_tag
#	output: 
#	toCall: &processOrphanModel($model_info_hsh_ref, $chain_info_hsh_ref, $gene_info_hsh_ref, $gene_num, $chrom_num, $novel_gene_prefix, $report_tag, $g_assign_hsh_ref);
#	calledInLine: 1409
#....................................................................................................................................................#
	my ($model_info_hsh_ref, $chain_info_hsh_ref, $gene_info_hsh_ref, $gene_num, $chrom_num, $novel_gene_prefix, $report_tag, $g_assign_hsh_ref) = @_;
	
	my $num_proc = 0;
	foreach my $chain_ID (keys %{$chain_info_hsh_ref}) {
		my $orphan_model_hsh_ref = {};
		$num_proc++;
		foreach my $model_ID (@{$chain_info_hsh_ref->{$chain_ID}{'MD'}}) {
			next if exists $model_info_hsh_ref->{$model_ID}{'gene_ID'}; #---[2023/08/04 19:14] only for orhpans
			$orphan_model_hsh_ref->{$model_ID}++;
		}
		
		my $exon_cluster_hsh_ref = {};
		foreach my $model_ID (keys %{$orphan_model_hsh_ref}) {
			die "Orphan model must have orphan clusters\n" if not exists $model_info_hsh_ref->{$model_ID}{'OCL'};
			foreach my $cluster_ID (@{$model_info_hsh_ref->{$model_ID}{'OCL'}}) {
				push @{$exon_cluster_hsh_ref->{$cluster_ID}}, $model_ID;
			}
		}
		
		my $exclude_hit_hsh_ref = {};
		foreach my $seed_model_ID (keys %{$orphan_model_hsh_ref}) {
			next if exists $exclude_hit_hsh_ref->{$seed_model_ID};

			my $all_hit_hsh_ref = {};
			my $cluster_key = 'OCL';
			($all_hit_hsh_ref) = &aggregateModel($all_hit_hsh_ref, $seed_model_ID, $model_info_hsh_ref, $exon_cluster_hsh_ref, $exclude_hit_hsh_ref, $cluster_key);#->203
			
			foreach my $hit_model_ID (keys %{$all_hit_hsh_ref}) {
				$exclude_hit_hsh_ref->{$hit_model_ID}++;
			}

			my $g_assign = $g_assign_hsh_ref->{'05'};
			($gene_num) = &assignNewGeneIDInChain($gene_num, $novel_gene_prefix, $chrom_num, $gene_info_hsh_ref, $chain_info_hsh_ref, $model_info_hsh_ref, $all_hit_hsh_ref, $g_assign, $chain_ID);#->241
		}
		
		&reportAndLogStatus("$report_tag Processing orphan models >>> $num_proc chains processed", 10, "\n") if $num_proc%1000==0;#->1613
		
	}
	&reportAndLogStatus("$report_tag Finished processing orphan models ### $num_proc chains processed", 10, "\n");#->1613

	return ();
}
sub processPerChromosome {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: cleanUpModelHsh|407, deepAmendHash|448, defineChainAndAssignGene|476, defineExonCluster|600, defineLocus|633, defineOrphanExonCluster|670, defineRefGeneExon|712, getModelBoundStr|749, getModelInChrom|789, intersectModelWithRefExon|840, processOrphanModel|1278, readRefGeneID|1569, reportAndLogStatus|1613, summarizeGeneInfo|1635
#	appearInSub: >none
#	primaryAppearInSection: 3_process|135
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $bgzip_bin, $chrom_info_hsh_ref, $disable_ref_chain_bound_gene_anno, $exclude_t_type, $exon_overlap_dist, $g_assign_hsh_ref, $locus_merge_dist, $max_thread, $min_ref_exon_overlap_pct, $model_bed_bgz, $model_info_gz, $novel_gene_prefix, $paramTag, $ref_model_gene_link, $revert_ref_model_bed_bgz, $tabix_bin
#	output: $chain_info_hsh_ref, $gene_info_hsh_ref, $locus_info_hsh_ref, $model_info_hsh_ref
#	toCall: my ($locus_info_hsh_ref, $chain_info_hsh_ref, $model_info_hsh_ref, $gene_info_hsh_ref) = &processPerChromosome($chrom_info_hsh_ref, $model_bed_bgz, $model_info_gz, $revert_ref_model_bed_bgz, $ref_model_gene_link, $novel_gene_prefix, $exon_overlap_dist, $locus_merge_dist, $bedtools_bin, $tabix_bin, $bgzip_bin, $max_thread, $paramTag, $exclude_t_type, $g_assign_hsh_ref, $disable_ref_chain_bound_gene_anno, $min_ref_exon_overlap_pct);
#	calledInLine: 148
#....................................................................................................................................................#
	my ($chrom_info_hsh_ref, $model_bed_bgz, $model_info_gz, $revert_ref_model_bed_bgz, $ref_model_gene_link, $novel_gene_prefix, $exon_overlap_dist, $locus_merge_dist, $bedtools_bin, $tabix_bin, $bgzip_bin, $max_thread, $paramTag, $exclude_t_type, $g_assign_hsh_ref, $disable_ref_chain_bound_gene_anno, $min_ref_exon_overlap_pct) = @_;
	
	my %chromForThrHsh = ();
	my $threadID = 1;
	foreach my $chrom (sort {$chrom_info_hsh_ref->{$b}{'size'} <=> $chrom_info_hsh_ref->{$a}{'size'}} keys %{$chrom_info_hsh_ref}) {
		$threadID = 1 if $threadID > $max_thread;
		$threadID = sprintf "%.2d", $threadID;
		push @{$chromForThrHsh{$threadID}} , $chrom;
		$threadID++;
	}
	
	my %threadHsh =();
	foreach my $threadID (sort {$a <=> $b} keys %chromForThrHsh) {
		my $chromForThrAry_ref = $chromForThrHsh{$threadID};
		($threadHsh{$threadID}) = threads->new(#---refer to http://www.perlmonks.org/?node_id=966781, the 
	
			sub {
				my ($chromForThrAry_ref) = @_;
				my $model_info_inThr_hsh_ref = {};
				my $locus_info_inThr_hsh_ref = {};
				my $chain_info_inThr_hsh_ref = {};
				my $gene_info_inThr_hsh_ref = {};
				
				foreach my $chrom (@{$chromForThrAry_ref}) {
					#---[2/19/16 13:13] do something on the item here
					my $chrom_num = $chrom_info_hsh_ref->{$chrom}{'chrom_num'};
					my $novel_gene_chrom_prefix = $novel_gene_prefix.$chrom_num;
					my $log_txt = $chrom_info_hsh_ref->{$chrom}{'log_txt'};
					my $tmp_txt = $chrom_info_hsh_ref->{$chrom}{'tmp_txt'};
					my $ref_gene_exon_bed = $chrom_info_hsh_ref->{$chrom}{'ref_gene_exon_bed'};
					my $exon_cluster_bed = $chrom_info_hsh_ref->{$chrom}{'exon_cluster_bed'};
					my $orhpan_exon_cluster_bed = $chrom_info_hsh_ref->{$chrom}{'orhpan_exon_cluster_bed'};

					my $report_tag = join " ", (sprintf("%-15s","Thread-$threadID $chrom"), ":");
					system ("rm -f $log_txt"); #---[2023/07/25 20:10] log as the sign for finish running the whole process
					my $log_ary_ref = [];
					&reportAndLogStatus("$report_tag >>>>>> Starting $chrom analysis <<<<<<", 10, "\n");#->1613
					
					&reportAndLogStatus("$report_tag Start Reading model bed ..........", 10, "\n");#->1613
					my ($model_info_hsh_ref) = &getModelInChrom($tabix_bin, $bedtools_bin, $model_bed_bgz, $revert_ref_model_bed_bgz, $chrom, $report_tag);#->789

					&reportAndLogStatus("$report_tag Start Reading model bound string ..........", 10, "\n");#->1613
					&getModelBoundStr($model_info_hsh_ref, $model_info_gz, $report_tag);#->749

					&reportAndLogStatus("$report_tag Start Reading ref gene ID ..........", 10, "\n");#->1613
					my ($gene_info_hsh_ref) = &readRefGeneID($model_info_hsh_ref, $ref_model_gene_link, $g_assign_hsh_ref, $report_tag);#->1569

					&reportAndLogStatus("$report_tag Start Defining ref gene exon ..........", 10, "\n");#->1613
					&defineRefGeneExon($ref_gene_exon_bed, $bgzip_bin, $model_info_hsh_ref, $tabix_bin, $bedtools_bin, $exclude_t_type);#->712

					&reportAndLogStatus("$report_tag Start Defining exon clusters ..........", 10, "\n");#->1613
					&defineExonCluster($bedtools_bin, $model_bed_bgz, $chrom, $report_tag, $model_info_hsh_ref, $exon_overlap_dist, $tabix_bin, $exon_cluster_bed, $bgzip_bin);#->600

					&reportAndLogStatus("$report_tag Start intersecting Ref exon ..........", 10, "\n");#->1613
					&intersectModelWithRefExon($bedtools_bin, $chrom, $report_tag, $model_info_hsh_ref, $ref_gene_exon_bed, $exon_cluster_bed, $g_assign_hsh_ref, $min_ref_exon_overlap_pct);#->840
					
					&reportAndLogStatus("$report_tag Start Defining locus ..........", 10, "\n");#->1613
					my ($locus_info_hsh_ref) = &defineLocus($tabix_bin, $bedtools_bin, $model_bed_bgz, $chrom, $model_info_hsh_ref, $report_tag, $locus_merge_dist, $chrom_num);#->633

					&reportAndLogStatus("$report_tag Start assigning gene ID per locus ..........", 10, "\n");#->1613
					my ($chain_info_hsh_ref, $gene_num) = &defineChainAndAssignGene($locus_info_hsh_ref, $model_info_hsh_ref, $report_tag, $chrom_num, $novel_gene_prefix, $gene_info_hsh_ref, $g_assign_hsh_ref, $chrom, $disable_ref_chain_bound_gene_anno);#->476
					
					&reportAndLogStatus("$report_tag Start defining orphan exon clusters ......", 10, "\n");#->1613
					&defineOrphanExonCluster($model_info_hsh_ref, $exon_cluster_bed, $orhpan_exon_cluster_bed, $bgzip_bin, $bedtools_bin, $exon_overlap_dist, $report_tag);#->670
					
					&reportAndLogStatus("$report_tag Start processing orphan models ......", 10, "\n");#->1613
					&processOrphanModel($model_info_hsh_ref, $chain_info_hsh_ref, $gene_info_hsh_ref, $gene_num, $chrom_num, $novel_gene_prefix, $report_tag, $g_assign_hsh_ref);#->1278
					
					&reportAndLogStatus("$report_tag Start summarizing gene info ......", 10, "\n");#->1613
					&summarizeGeneInfo($gene_info_hsh_ref, $model_info_hsh_ref, $chain_info_hsh_ref, $g_assign_hsh_ref);#->1635

					my $key_delete_ary_ref = ['CL', 'OCL'];
					&cleanUpModelHsh($model_info_hsh_ref, $key_delete_ary_ref);#->407

					$locus_info_inThr_hsh_ref->{$chrom} = $locus_info_hsh_ref;
					$chain_info_inThr_hsh_ref->{$chrom} = $chain_info_hsh_ref;
					$model_info_inThr_hsh_ref->{$chrom} = $model_info_hsh_ref;
					$gene_info_inThr_hsh_ref->{$chrom} = $gene_info_hsh_ref;

				}
				
				return ($chain_info_inThr_hsh_ref, $locus_info_inThr_hsh_ref, $model_info_inThr_hsh_ref, $gene_info_inThr_hsh_ref);
			}
			,($chromForThrAry_ref)
		);
	}
	
	my $locus_info_hsh_ref = {};
	my $chain_info_hsh_ref = {};
	my $model_info_hsh_ref = {};
	my $gene_info_hsh_ref = {};
	
	my $master_hsh_ref = {
		'locus' => $locus_info_hsh_ref,
		'chain' => $chain_info_hsh_ref,
		'model' => $model_info_hsh_ref,
		'gene' => $gene_info_hsh_ref,
	};
	
	while (keys %threadHsh) {
		my $num_thread = keys %threadHsh;
		&reportAndLogStatus("--------------------------- $num_thread thread running ---------------------------", 10, "\n");#->1613
		foreach my $threadID (keys %threadHsh) {
			if (not $threadHsh{$threadID}->is_running()) {
				my ($chain_info_inThr_hsh_ref, $locus_info_inThr_hsh_ref, $model_info_inThr_hsh_ref, $gene_info_inThr_hsh_ref) = $threadHsh{$threadID}->join();
				foreach my $chrom (@{$chromForThrHsh{$threadID}}) {
					&reportAndLogStatus(">>>>>> thread $threadID collecting $chrom info <<<<<<", 10, "\n");#->1613
					my $inThr_hsh_ref = {
						'locus' => $locus_info_inThr_hsh_ref->{$chrom},
						'chain' => $chain_info_inThr_hsh_ref->{$chrom},
						'model' => $model_info_inThr_hsh_ref->{$chrom},
						'gene' => $gene_info_inThr_hsh_ref->{$chrom},
					};
					foreach my $item_type (keys %{$master_hsh_ref}) {
						&deepAmendHash($inThr_hsh_ref->{$item_type}, $master_hsh_ref->{$item_type});#->448
					}
				}
				delete $threadHsh{$threadID};
				&reportAndLogStatus(">>>>>>>>>>>>>>>>>>>>>>>> thread $threadID finished <<<<<<<<<<<<<<<<<<<<<<<<<<<", 10, "\n");#->1613
			}
		}
		sleep 1;
	}
	return ($locus_info_hsh_ref, $chain_info_hsh_ref, $model_info_hsh_ref, $gene_info_hsh_ref);
}
sub readParameters {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startingTasks|89
#	secondaryAppearInSection: >none
#	input: none
#	output: $bedtools_bin, $bgzip_bin, $chrom_size_path, $disable_ref_chain_bound_gene_anno, $exclude_t_type, $exon_overlap_dist, $locus_merge_dist, $max_thread, $min_ref_exon_overlap_pct, $model_bed_bgz, $model_info_gz, $novel_gene_prefix, $out_dir, $out_prefix, $ref_model_gene_link, $revert_ref_model_bed_bgz, $tabix_bin
#	toCall: my ($model_bed_bgz, $model_info_gz, $ref_model_gene_link, $novel_gene_prefix, $exon_overlap_dist, $min_ref_exon_overlap_pct, $locus_merge_dist, $exclude_t_type, $revert_ref_model_bed_bgz, $disable_ref_chain_bound_gene_anno, $chrom_size_path, $bedtools_bin, $tabix_bin, $bgzip_bin, $max_thread, $out_prefix, $out_dir) = &readParameters();
#	calledInLine: 92
#....................................................................................................................................................#
	
	my ($model_bed_bgz, $model_info_gz, $ref_model_gene_link, $novel_gene_prefix, $exon_overlap_dist, $min_ref_exon_overlap_pct, $locus_merge_dist, $exclude_t_type, $revert_ref_model_bed_bgz, $disable_ref_chain_bound_gene_anno, $chrom_size_path, $bedtools_bin, $tabix_bin, $bgzip_bin, $max_thread, $out_prefix, $out_dir);
	
	$novel_gene_prefix = 'ONTG';
	$max_thread = 5;
	$revert_ref_model_bed_bgz = undef;
	$bedtools_bin = 'bedtools';
	$exon_overlap_dist = -1; #---[2023/08/02 20:14] means the exon has be to 1nt overlap
	$tabix_bin = 'tabix';
	$bgzip_bin = 'bgzip';
	$locus_merge_dist = 10000;
	$min_ref_exon_overlap_pct = 50;
	$disable_ref_chain_bound_gene_anno = 'no';
	$out_prefix = 'assemble_gene_annotator';
	$exclude_t_type = undef; #---[2023/08/03 22:27] could be comma delimited

	GetOptions 	(
		"model_bed_bgz=s"								=>	\$model_bed_bgz,
		"model_info_gz=s"								=>	\$model_info_gz,
		"ref_model_gene_link=s"						=>	\$ref_model_gene_link,
		"novel_gene_prefix=s"						=>	\$novel_gene_prefix,
		"min_ref_exon_overlap_pct:s"				=>	\$min_ref_exon_overlap_pct,
		"chrom_size_path:s"							=>	\$chrom_size_path,
		"revert_ref_model_bed_bgz:s"				=>	\$revert_ref_model_bed_bgz,
		"disable_ref_chain_bound_gene_anno:s"	=>	\$disable_ref_chain_bound_gene_anno,
		"exclude_t_type:s"							=>	\$exclude_t_type,
		"bedtools_bin:s"								=>	\$bedtools_bin,
		"tabix_bin:s"									=>	\$tabix_bin,
		"bgzip_bin:s"									=>	\$bgzip_bin,
		"exon_overlap_dist:i"						=>	\$exon_overlap_dist,
		"locus_merge_dist:i"							=>	\$locus_merge_dist,
		"max_thread:i"									=>	\$max_thread,
		"out_prefix:s"									=>	\$out_prefix,
		"out_dir=s"										=>	\$out_dir,
		'help'											=>	sub { HelpMessage(0) },
	) or HelpMessage(1);

	my $opt_check_hsh_ref = {
		'model_bed_bgz' => $model_bed_bgz,
		'model_info_gz' => $model_info_gz,
		'ref_model_gene_link' => $ref_model_gene_link,
		'out_dir' => $out_dir,
	};
	
	my $required = 'yes';
	print "\n";
	foreach my $option_name (keys %{$opt_check_hsh_ref}) {
		if (not defined $opt_check_hsh_ref->{$option_name}) {
			print "WARNING: option \"$option_name\" is requied\n";
			$required = 'no';
		}
	}
	if ($required eq 'no') {
		print "WARNING: quitting. Please check this help message for required options\n";
		print "\n";
		HelpMessage(1);
	}

	#---check file
	my $file_check_hsh_ref = {
		'model_bed_bgz' => $model_bed_bgz,
		'model_info_gz' => $model_info_gz,
		'ref_model_gene_link' => $ref_model_gene_link,
	};
	
	foreach my $option_name (keys %{$file_check_hsh_ref}) {
		my $file_path = $file_check_hsh_ref->{$option_name};
		if (not -s $file_path) {
			die "Quitting: File $option_name does not exists at $file_path";
		}
	}

	foreach my $bgz_path ($model_bed_bgz) {
		if ($bgz_path !~ m/\.bed\.bgz$/) {
			die "Quitting: $bgz_path must be in *.bed.bgz format\n";
		}
		
		if (not -s "$bgz_path.tbi") {
			die "Quitting: $bgz_path must be be indexed as *.bed.bgz.tbi using tabix\n";
		}
	}
	
	chop $out_dir if ($out_dir =~ m/\/$/); #---remove the last slash
	system "mkdir -p -m 755 $out_dir/";
	
	return($model_bed_bgz, $model_info_gz, $ref_model_gene_link, $novel_gene_prefix, $exon_overlap_dist, $min_ref_exon_overlap_pct, $locus_merge_dist, $exclude_t_type, $revert_ref_model_bed_bgz, $disable_ref_chain_bound_gene_anno, $chrom_size_path, $bedtools_bin, $tabix_bin, $bgzip_bin, $max_thread, $out_prefix, $out_dir);

}
sub readRefGeneID {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: assignRefGeneIDByInheritance|288, reportAndLogStatus|1613
#	appearInSub: processPerChromosome|1332
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_process|135
#	input: $g_assign_hsh_ref, $model_info_hsh_ref, $ref_model_gene_link, $report_tag
#	output: $gene_info_hsh_ref
#	toCall: my ($gene_info_hsh_ref) = &readRefGeneID($model_info_hsh_ref, $ref_model_gene_link, $g_assign_hsh_ref, $report_tag);
#	calledInLine: 1388
#....................................................................................................................................................#
	my ($model_info_hsh_ref, $ref_model_gene_link, $g_assign_hsh_ref, $report_tag) = @_;
	
	my $gene_info_hsh_ref = {};
	if ($ref_model_gene_link =~ m/\.gz$/) {
		open (REFGENE, " gzip -dc $ref_model_gene_link|");
	} else {
		open (REFGENE, "<", $ref_model_gene_link);
	}
	my $num_proc = 0;
	while (<REFGENE>) {
		chomp;
		my ($model_ID, $gene_ID, $t_type, $g_type, $gene_name) = split /\t/;
		next if not exists $model_info_hsh_ref->{$model_ID};
		$num_proc++;
		$model_info_hsh_ref->{$model_ID}{'t_type'} = $t_type;
		$model_info_hsh_ref->{$model_ID}{'ref'} = 'Y';
		&assignRefGeneIDByInheritance($model_ID, $gene_ID, $gene_info_hsh_ref, $g_type, $gene_name, $model_info_hsh_ref, $g_assign_hsh_ref);#->288
	}
	
	#model_ID	loc	completeness	full_set_ID	end5_endtype	end3_endtype	novelty	strand	partial_set_count	partial_set_ID_str	full_ref_count	full_qry_count	partial_ref_count	partial_qry_count	full_set_bound_str
	#ENST00000003583.12	chr1:24356998-24413732	Y	S0112948	S	S	ref	-	13	S01107511;S01110032;S01112747;S01114097;S01132803;S01195805;S0125668;S0126631;S01304401;S015012;S015854;S0175586;S0178341	1	63	0	3	F011490_J0126532_J0126531_J0126530_J0126529_J0126538_J0126537_J0126527_T012830_-
	#ENST00000003912.7	chr1:24415801-24472976	Y	S01329628	S	S	ref	+	7	S01151723;S01176821;S0121844;S01241915;S01276884;S0187263;S0188622	1	0	0	1	F011493_J0126605_J0126632_J01149962_J0126590_J0126591_J0126592_J0126593_J0126594_J0126595_J0126596_J0126597_J0126598_T012851_+
	#ENST00000008440.9	chr1:231338292-231352526	Y	S01154117	S	S	ref	+	7	S01166811;S01185748;S01214023;S01216449;S0156393;S0156614;S0182985	1	2	0	1	F018833_J01141910_J01141916_T0117766_+
	#ENST00000009105.5	chr1:209583713-209613939	Y	S01329629	S	S	ref	+	1	S0149239	1	0	0	1	F018044_J01158863_J01131368_J01131369_J01131370_J01131371_J01131372_J01131373_J01131374_J01131375_J01131376_J01131377_J01131378_T0116221_+
	close REFGENE;
	
	my $total_num = keys %{$model_info_hsh_ref};
	
	&reportAndLogStatus("$report_tag Finished reading ref gene ID ### $num_proc of $total_num models have ref geneID", 10, "\n");#->1613

	return ($gene_info_hsh_ref);
}
sub reportAndLogStatus {
#....................................................................................................................................................#
#	subroutineCategory: log
#	dependOnSub: currentTime|430
#	appearInSub: aggregateModel|203, defineChainAndAssignGene|476, defineChromInfo|549, defineExonCluster|600, defineLocus|633, defineOrphanExonCluster|670, getModelBoundStr|749, getModelInChrom|789, intersectModelWithRefExon|840, printChainInfoAndBed|914, printGeneInfoAndBed|989, printModelInfoAndBed|1059, processOrphanModel|1278, processPerChromosome|1332, readRefGeneID|1569
#	primaryAppearInSection: 2_defineout_dirPath|105, 3_process|135
#	secondaryAppearInSection: 3_process|135
#	input: $lineEnd, $message, $numTrailingSpace
#	output: 
#	toCall: &reportAndLogStatus($message, $numTrailingSpace, $lineEnd);
#	calledInLine: 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 130, 149, 151, 153, 231, 542, 544, 563, 593, 624, 628, 661, 665, 703, 707, 776, 784, 814, 818, 834, 861, 864, 974, 980, 982, 1045, 1051, 1053, 1104, 1121, 1123, 1324, 1327, 1379, 1381, 1384, 1387, 1390, 1393, 1396, 1399, 1402, 1405, 1408, 1411, 1444, 1449, 1461, 1608
#....................................................................................................................................................#
	my ($message, $numTrailingSpace, $lineEnd) = @_;

	my $trailingSpaces = '';
	$trailingSpaces .= " " for (1..$numTrailingSpace);
	
	print "[".&currentTime()."] ".$message.$trailingSpaces.$lineEnd;#->430
	print $tmplog_fh "[".&currentTime()."] ".$message.$lineEnd if $lineEnd ne "\r";#->430
	
	return ();
}
sub summarizeGeneInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: processPerChromosome|1332
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_process|135
#	input: $chain_info_hsh_ref, $g_assign_hsh_ref, $gene_info_hsh_ref, $model_info_hsh_ref
#	output: 
#	toCall: &summarizeGeneInfo($gene_info_hsh_ref, $model_info_hsh_ref, $chain_info_hsh_ref, $g_assign_hsh_ref);
#	calledInLine: 1412
#....................................................................................................................................................#
	my ($gene_info_hsh_ref, $model_info_hsh_ref, $chain_info_hsh_ref, $g_assign_hsh_ref) = @_;

	foreach my $chain_ID (keys %{$chain_info_hsh_ref}) {
		die "chain $chain_ID does not have geneID\n" if not exists $chain_info_hsh_ref->{$chain_ID}{'gene_ID'};
		foreach my $gene_ID (@{$chain_info_hsh_ref->{$chain_ID}{'gene_ID'}}) {
			push @{$gene_info_hsh_ref->{$gene_ID}{'CN'}}, $chain_ID;
		}
	}
	foreach my $model_ID (keys %{$model_info_hsh_ref}) {
		my $gene_ID = $model_info_hsh_ref->{$model_ID}{'gene_ID'};
		my ($completeness, $full_ref_count, $full_qry_count, $partial_ref_count, $partial_qry_count) = @{$model_info_hsh_ref->{$model_ID}{'info'}};
		
		$gene_info_hsh_ref->{$gene_ID}{'CMD'}++ if $completeness eq 'Y';
		$gene_info_hsh_ref->{$gene_ID}{'QC'} += $full_qry_count + $partial_qry_count;
		
		push @{$gene_info_hsh_ref->{$gene_ID}{'MD'}}, $model_ID;
		my $strand = $model_info_hsh_ref->{$model_ID}{'bed'}[5];
		my $chrom = $model_info_hsh_ref->{$model_ID}{'bed'}[0];
		if (not exists $gene_info_hsh_ref->{$gene_ID}{'ST'}) {
			$gene_info_hsh_ref->{$gene_ID}{'ST'} = $strand;
			$gene_info_hsh_ref->{$gene_ID}{'CH'} = $chrom;
		} else {
			die "$gene_ID contains multiple strands\n" if $strand ne $gene_info_hsh_ref->{$gene_ID}{'ST'};
			die "$gene_ID contains multiple chrom\n" if $chrom ne $gene_info_hsh_ref->{$gene_ID}{'CH'};
		}
	}

	foreach my $gene_ID (keys %{$gene_info_hsh_ref}) {
		$gene_info_hsh_ref->{$gene_ID}{'CMD'} = 0 if not exists $gene_info_hsh_ref->{$gene_ID}{'CMD'};
		my @rng_ary = ();
		foreach my $key (keys %{$g_assign_hsh_ref}) {
			my $g_assign = $g_assign_hsh_ref->{$key};
			$gene_info_hsh_ref->{$gene_ID}{'GA'}{$g_assign} = 0;
		}
		foreach my $model_ID (@{$gene_info_hsh_ref->{$gene_ID}{'MD'}}) {
			push @rng_ary, $model_info_hsh_ref->{$model_ID}{'bed'}[1];
			push @rng_ary, $model_info_hsh_ref->{$model_ID}{'bed'}[2];
			my $g_assign = $model_info_hsh_ref->{$model_ID}{'g_assign'};
			$gene_info_hsh_ref->{$gene_ID}{'GA'}{$g_assign}++;
		}
		@rng_ary = sort {$a <=> $b} @rng_ary;
		$gene_info_hsh_ref->{$gene_ID}{'rng'} = [$rng_ary[0], $rng_ary[-1]];
	}
	
	return ();
}
sub timeStamp {
#....................................................................................................................................................#
#	subroutineCategory: time, general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: none
#	output: $curntTimeStamp
#	toCall: my ($curntTimeStamp) = &timeStamp();
#	calledInLine: 77
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $curntTimeStamp = sprintf "%04d.%02d.%02d.%02d.%02d.%02d", $year+1900,$mon+1,$mday,$hour,$min,$sec;	

	return ($curntTimeStamp);
}

exit;


















































